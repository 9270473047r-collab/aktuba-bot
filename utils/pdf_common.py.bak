import os
import re
from datetime import datetime
from typing import Optional, List, Any, Dict

from fpdf import FPDF

# fpdf2 wrap mode
try:
    from fpdf.enums import WrapMode
except Exception:
    WrapMode = None


# ─────────────────────────────────────────────────────────────
# ШРИФТЫ (Linux)
# ─────────────────────────────────────────────────────────────
_DEFAULT_FONT_REGULAR_CANDIDATES = [
    os.getenv("PDF_FONT_REGULAR", "").strip(),
    "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
    "/usr/share/fonts/truetype/dejavu/DejaVuSansCondensed.ttf",
]

_DEFAULT_FONT_BOLD_CANDIDATES = [
    os.getenv("PDF_FONT_BOLD", "").strip(),
    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
    "/usr/share/fonts/truetype/dejavu/DejaVuSansCondensed-Bold.ttf",
]


def _first_existing(paths: List[str]) -> Optional[str]:
    for p in paths:
        if p and os.path.exists(p):
            return p
    return None


FONT_REGULAR_PATH = _first_existing(_DEFAULT_FONT_REGULAR_CANDIDATES)
FONT_BOLD_PATH = _first_existing(_DEFAULT_FONT_BOLD_CANDIDATES)
FONT_FAMILY = "DejaVu"


# ─────────────────────────────────────────────────────────────
# ТЕКСТ: безопасный вывод для PDF
# ─────────────────────────────────────────────────────────────
_EMOJI_RE = re.compile(
    "["
    "\U0001F300-\U0001F5FF"
    "\U0001F600-\U0001F64F"
    "\U0001F680-\U0001F6FF"
    "\U0001F700-\U0001F77F"
    "\U0001F780-\U0001F7FF"
    "\U0001F800-\U0001F8FF"
    "\U0001F900-\U0001F9FF"
    "\U0001FA00-\U0001FAFF"
    "\u2600-\u26FF"
    "\u2700-\u27BF"
    "]+",
    flags=re.UNICODE,
)


def safe_text(val: Any) -> str:
    """
    Превращает любое значение в безопасную строку для fpdf2.
    Убирает эмодзи, нормализует пробелы, защищает переносы.
    """
    if val is None:
        s = ""
    else:
        s = str(val)

    s = s.replace("\r\n", "\n").replace("\r", "\n")
    s = _EMOJI_RE.sub("", s)
    s = re.sub(r"[ \t]+", " ", s).strip()
    return s


# ─────────────────────────────────────────────────────────────
# PDF: базовые настройки и байты
# ─────────────────────────────────────────────────────────────
def setup_pdf(pdf: FPDF):
    pdf.set_auto_page_break(auto=True, margin=12)
    pdf.set_margins(12, 12, 12)
    pdf.set_creator("aktuba_bot")
    pdf.set_title("Report")
    pdf.set_subject("Report")

    # Шрифты
    if FONT_REGULAR_PATH and FONT_BOLD_PATH:
        try:
            pdf.add_font(FONT_FAMILY, "", FONT_REGULAR_PATH, uni=True)
            pdf.add_font(FONT_FAMILY, "B", FONT_BOLD_PATH, uni=True)
        except Exception:
            pass

    if FONT_REGULAR_PATH and FONT_BOLD_PATH:
        pdf.set_font(FONT_FAMILY, "", 10)
    else:
        pdf.set_font("Helvetica", "", 10)


def set_font(pdf: FPDF, bold: bool = False, size: int = 10):
    if FONT_REGULAR_PATH and FONT_BOLD_PATH:
        pdf.set_font(FONT_FAMILY, "B" if bold else "", size)
    else:
        pdf.set_font("Helvetica", "B" if bold else "", size)


def _pdf_bytes(pdf: FPDF) -> bytes:
    """
    fpdf2 output(dest="S") возвращает bytearray -> приводим к bytes.
    """
    out = pdf.output(dest="S")
    if isinstance(out, (bytes, bytearray)):
        return bytes(out)
    return str(out).encode("latin1", errors="ignore")


# ─────────────────────────────────────────────────────────────
# РЕНДЕР: безопасные многострочные строки (не падают на длинных словах)
# ─────────────────────────────────────────────────────────────
def mc(pdf: FPDF, text: str, h: float = 5.6):
    """
    Безопасный multi_cell:
      - всегда сбрасывает X в левое поле
      - wrapmode=CHAR (никогда не падает на "длинном слове")
    """
    pdf.set_x(pdf.l_margin)
    if WrapMode is not None:
        pdf.multi_cell(0, h, safe_text(text), wrapmode=WrapMode.CHAR)
    else:
        # fallback
        pdf.multi_cell(0, h, safe_text(text))


def header_block(pdf: FPDF, title: str, subtitle: str = ""):
    pdf.add_page()

    # цветная шапка
    pdf.set_fill_color(33, 150, 243)
    pdf.rect(0, 0, 210, 22, style="F")

    pdf.set_text_color(255, 255, 255)
    set_font(pdf, bold=True, size=14)
    pdf.set_xy(12, 6)
    pdf.cell(0, 8, safe_text(title), border=0)

    if subtitle:
        set_font(pdf, bold=False, size=10)
        pdf.set_xy(12, 14)
        pdf.cell(0, 6, safe_text(subtitle), border=0)

    pdf.set_text_color(0, 0, 0)
    pdf.ln(14)


def section_title(pdf: FPDF, text: str):
    pdf.ln(1)
    set_font(pdf, bold=True, size=11)
    pdf.set_text_color(33, 33, 33)
    mc(pdf, text, h=6.2)
    pdf.set_text_color(0, 0, 0)


def bullet(pdf: FPDF, text: str):
    set_font(pdf, bold=False, size=10)
    mc(pdf, f"• {text}", h=5.6)


def kv(pdf: FPDF, label: str, value: str):
    set_font(pdf, bold=True, size=10)
    pdf.set_x(pdf.l_margin)
    pdf.cell(0, 5.6, safe_text(label), ln=1)

    set_font(pdf, bold=False, size=10)
    mc(pdf, safe_text(value), h=5.6)


# ─────────────────────────────────────────────────────────────
# ───── СОВМЕСТИМОСТЬ СО СТАРЫМ API (чтобы бот стартовал) ─────
# utils/pdf_mtp_directory.py импортирует:
#   add_title, new_pdf, section, table, pdf_bytes
# ─────────────────────────────────────────────────────────────
def new_pdf(*, orientation: str = "P", unit: str = "mm", format: str = "A4") -> FPDF:
    """
    Старый API: создаёт PDF и применяет базовые настройки.
    """
    pdf = FPDF(orientation=orientation, unit=unit, format=format)
    setup_pdf(pdf)
    pdf.add_page()
    return pdf


def add_title(pdf: FPDF, title: str, subtitle: str = ""):
    """
    Старый API: заголовок документа (простая версия).
    """
    # сделаем аккуратный заголовок без рисков переносов
    set_font(pdf, bold=True, size=14)
    mc(pdf, title, h=7.0)
    if subtitle:
        set_font(pdf, bold=False, size=10)
        mc(pdf, subtitle, h=5.6)
    pdf.ln(2)


def section(pdf: FPDF, title: str):
    """
    Старый API: заголовок секции.
    """
    section_title(pdf, title)


def table(
    pdf: FPDF,
    headers: List[str],
    rows: List[List[Any]],
    col_widths: Optional[List[float]] = None,
    *,
    header_fill: bool = True,
):
    """
    Старый API: простая таблица.
    Главное — НЕ падать на длинных строках. Поэтому:
      - печатаем строки ячейками фиксированной ширины
      - перенос по символам внутри ячейки
    """
    if not headers:
        return

    page_w = pdf.w - pdf.l_margin - pdf.r_margin
    n = len(headers)

    if not col_widths or len(col_widths) != n:
        col_widths = [page_w / n] * n

    # HEADER
    set_font(pdf, bold=True, size=10)
    if header_fill:
        pdf.set_fill_color(230, 240, 255)
    y0 = pdf.get_y()
    x0 = pdf.l_margin
    row_h = 6.0

    pdf.set_x(x0)
    for i, h in enumerate(headers):
        txt = safe_text(h)
        pdf.multi_cell(
            col_widths[i], row_h, txt,
            border=1,
            fill=header_fill,
            new_x="RIGHT",
            new_y="TOP",
            wrapmode=(WrapMode.CHAR if WrapMode is not None else None),
        )
    pdf.set_y(y0 + row_h)

    # ROWS
    set_font(pdf, bold=False, size=9)

    for r in rows or []:
        # нормализуем длину строки
        r = list(r) + [""] * (n - len(r))
        r = r[:n]

        y_start = pdf.get_y()
        x = pdf.l_margin
        max_y = y_start

        # сначала измерим высоту каждой ячейки через multi_cell в режиме TOP,
        # чтобы выровнять ряд по максимальной высоте
        cell_heights = []
        for i in range(n):
            pdf.set_xy(x, y_start)
            text = safe_text(r[i])
            pdf.multi_cell(
                col_widths[i], 5.2, text,
                border=1,
                new_x="RIGHT",
                new_y="TOP",
                wrapmode=(WrapMode.CHAR if WrapMode is not None else None),
            )
            y_after = pdf.get_y()
            cell_heights.append(y_after - y_start)
            max_y = max(max_y, y_after)
            x += col_widths[i]

        # выравниваем по max_y
        pdf.set_y(max_y)


def pdf_bytes(pdf: FPDF) -> bytes:
    """
    Старый API: вернуть PDF как bytes.
    """
    return _pdf_bytes(pdf)
